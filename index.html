<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Magical Christmas Tree | Creative Tech</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Times+New+Roman&display=swap"
    rel="stylesheet">

  <style>
    :root {
      --gold: #d4af37;
      --cream: #fceea7;
      --bg: #000000;
    }

    body {
      margin: 0;
      overflow: hidden;
      background-color: var(--bg);
      font-family: 'Times New Roman', serif;
      color: var(--gold);
      user-select: none;
    }

    /* UI Overlay */
    #ui-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
      transition: opacity 0.5s ease;
    }

    /* Hidden State */
    .ui-hidden {
      opacity: 0 !important;
      pointer-events: none !important;
    }

    /* Title */
    h1 {
      font-family: 'Cinzel', serif;
      font-size: 56px;
      text-align: center;
      margin-top: 40px;
      background: linear-gradient(to bottom, #ffffff, var(--gold));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
      letter-spacing: 4px;
    }

    /* Controls */
    .controls-area {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .upload-wrapper {
      position: relative;
      overflow: hidden;
      display: inline-block;
    }

    .btn {
      background: rgba(20, 20, 20, 0.4);
      backdrop-filter: blur(10px);
      border: 1px solid var(--gold);
      color: var(--gold);
      padding: 12px 30px;
      font-family: 'Cinzel', serif;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
      box-shadow: 0 0 15px rgba(212, 175, 55, 0.1);
    }

    .btn:hover {
      background: rgba(212, 175, 55, 0.1);
      box-shadow: 0 0 25px rgba(212, 175, 55, 0.3);
    }

    input[type="file"] {
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .hint {
      font-size: 12px;
      opacity: 0.7;
      color: var(--cream);
      margin-top: 8px;
    }

    /* Loader */
    #loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: 999;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      transition: opacity 0.8s ease;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 2px solid rgba(212, 175, 55, 0.1);
      border-top: 2px solid var(--gold);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    .loader-text {
      font-family: 'Cinzel', serif;
      font-size: 14px;
      letter-spacing: 4px;
      color: var(--gold);
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    /* Webcam Container (Invisible but active) */
    #webcam-container {
      position: absolute;
      bottom: 10px;
      right: 10px;
      opacity: 0;
      /* Hidden as requested */
      pointer-events: none;
    }
  </style>

  <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>

<body>

  <div id="loader">
    <div class="spinner"></div>
    <div class="loader-text">LOADING HOLIDAY MAGIC</div>
  </div>

  <div id="ui-container">
    <h1>Merry Christmas</h1>

    <div class="controls-area">
      <div class="upload-wrapper">
        <button class="btn">ADD MEMORIES</button>
        <input type="file" id="imageInput" accept="image/*">
      </div>
      <div class="hint">Press 'H' to Hide Controls</div>
    </div>
  </div>

  <div id="webcam-container">
    <video id="webcam" autoplay playsinline></video>
    <canvas id="cv-canvas" width="160" height="120"></canvas>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    // PMREMGenerator is now in core THREE, no import needed from addons
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // --- Config ---
    const CONFIG = {
      colors: { gold: 0xd4af37, cream: 0xfceea7, red: 0x8a0303, green: 0x0f3b1e, blue: 0x1e3b5e },
      counts: { main: 1500, dust: 2500 },
      cameraPos: new THREE.Vector3(0, 2, 50),
      focusPos: new THREE.Vector3(0, 2, 35)
    };

    const STATE = {
      mode: 'TREE', // TREE, SCATTER, FOCUS
      targetPhotoIndex: -1,
      handRotation: { x: 0, y: 0 }
    };

    class ChristmasExperience {
      constructor() {
        this.container = document.body;
        this.particles = [];
        this.photos = [];
        this.dummy = new THREE.Object3D();
        this.clock = new THREE.Clock();
        this.raycaster = new THREE.Raycaster();

        // Init
        this.init();
      }

      async init() {
        this.setupThree();
        this.setupLights();
        this.setupPostProcessing();
        this.createMaterials();
        this.generateContent();
        this.setupEventListeners();

        try {
          await this.setupMediaPipe();
          this.startWebcam();
        } catch (e) {
          console.warn("CV Init Failed:", e);
        }

        // Hide Loader
        const loader = document.getElementById('loader');
        loader.style.opacity = '0';
        setTimeout(() => loader.remove(), 800);

        this.animate();
      }

      setupThree() {
        // Renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.toneMapping = THREE.ReinhardToneMapping;
        this.renderer.toneMappingExposure = 2.2;
        document.body.appendChild(this.renderer.domElement);

        // Scene & Camera
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.copy(CONFIG.cameraPos);

        // Environment
        // Using THREE.PMREMGenerator (core) instead of imported module
        const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
        this.scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

        // Main Group for Rotation
        this.mainGroup = new THREE.Group();
        this.scene.add(this.mainGroup);

        // Controls (Optional mouse fallback)
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
      }

      setupLights() {
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambient);

        const point = new THREE.PointLight(0xffaa00, 2, 50);
        this.mainGroup.add(point);

        const spot1 = new THREE.SpotLight(CONFIG.colors.gold, 1200);
        spot1.position.set(30, 40, 40);
        spot1.angle = 0.5;
        spot1.penumbra = 0.5;
        this.scene.add(spot1);

        const spot2 = new THREE.SpotLight(0x4444ff, 600); // Blue contrast
        spot2.position.set(-30, 20, -30);
        this.scene.add(spot2);
      }

      setupPostProcessing() {
        this.composer = new EffectComposer(this.renderer);
        const renderPass = new RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          0.45, // Strength
          0.4,  // Radius
          0.7   // Threshold
        );
        this.composer.addPass(bloomPass);
      }

      createMaterials() {
        this.matGold = new THREE.MeshStandardMaterial({
          color: CONFIG.colors.gold, roughness: 0.1, metalness: 0.8
        });
        this.matGreen = new THREE.MeshStandardMaterial({
          color: CONFIG.colors.green, roughness: 0.3, metalness: 0.2
        });
        this.matRed = new THREE.MeshPhysicalMaterial({
          color: CONFIG.colors.red, roughness: 0.1, metalness: 0.1, clearcoat: 1.0
        });
        this.matPhotoFrame = new THREE.MeshStandardMaterial({
          color: CONFIG.colors.gold, roughness: 0.2, metalness: 0.9
        });
      }

      // --- Content Generation ---

      createCandyCaneGeometry() {
        const path = new THREE.CatmullRomCurve3([
          new THREE.Vector3(0, -0.5, 0),
          new THREE.Vector3(0, 0.5, 0),
          new THREE.Vector3(0.2, 0.7, 0),
          new THREE.Vector3(0.4, 0.5, 0)
        ]);

        // Procedural Texture
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, 128, 128);
        ctx.fillStyle = '#cc0000';
        for (let i = 0; i < 10; i++) {
          ctx.beginPath();
          ctx.moveTo(i * 20, 0); ctx.lineTo(i * 20 + 10, 0);
          ctx.lineTo(i * 20 - 20, 128); ctx.lineTo(i * 20 - 30, 128);
          ctx.fill();
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;

        return {
          geo: new THREE.TubeGeometry(path, 20, 0.05, 8, false),
          mat: new THREE.MeshStandardMaterial({ map: tex, roughness: 0.2 })
        };
      }

      createPhotoMesh(texture) {
        const group = new THREE.Group();
        // Frame
        const frame = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 0.1), this.matPhotoFrame);
        // Photo
        const photoMat = new THREE.MeshBasicMaterial({ map: texture });
        const photo = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), photoMat);
        photo.position.z = 0.06;

        group.add(frame);
        group.add(photo);
        group.userData.isPhoto = true;
        return group;
      }

      generateDefaultPhoto() {
        const cvs = document.createElement('canvas');
        cvs.width = 512; cvs.height = 512;
        const ctx = cvs.getContext('2d');
        ctx.fillStyle = '#111'; ctx.fillRect(0, 0, 512, 512);
        ctx.strokeStyle = '#d4af37'; ctx.lineWidth = 10;
        ctx.strokeRect(20, 20, 472, 472);
        ctx.font = 'bold 60px Cinzel';
        ctx.fillStyle = '#fceea7';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('JOYEUX', 256, 220);
        ctx.fillText('NOEL', 256, 292);
        const tex = new THREE.CanvasTexture(cvs);
        tex.colorSpace = THREE.SRGBColorSpace;
        return this.createPhotoMesh(tex);
      }

      generateContent() {
        const caneData = this.createCandyCaneGeometry();
        const boxGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        const sphereGeo = new THREE.SphereGeometry(0.2, 32, 32);

        // Add Default Photo
        const defaultPhoto = this.generateDefaultPhoto();
        this.addParticleToSystem(defaultPhoto, 'PHOTO');

        // Generate Main Particles
        for (let i = 0; i < CONFIG.counts.main; i++) {
          let mesh, type = 'ORNAMENT';
          const rand = Math.random();

          if (rand < 0.1) {
            mesh = new THREE.Mesh(caneData.geo, caneData.mat);
            type = 'CANE';
          } else if (rand < 0.5) {
            mesh = new THREE.Mesh(boxGeo, Math.random() > 0.5 ? this.matGold : this.matGreen);
          } else {
            mesh = new THREE.Mesh(sphereGeo, Math.random() > 0.5 ? this.matGold : this.matRed);
          }

          // Random scale variance
          const s = 0.5 + Math.random() * 1.0;
          mesh.scale.set(s, s, s);
          this.addParticleToSystem(mesh, type);
        }

        // Generate Dust (Simple InstancedMesh could be used here, but using Mesh for uniform logic for now)
        const dustGeo = new THREE.TetrahedronGeometry(0.05);
        const dustMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 });
        for (let i = 0; i < CONFIG.counts.dust; i++) {
          const mesh = new THREE.Mesh(dustGeo, dustMat);
          this.addParticleToSystem(mesh, 'DUST');
        }
      }

      addParticleToSystem(mesh, type) {
        // Initialize Random Position (Scatter Mode base)
        const r = 8 + Math.random() * 12; // Radius 8-20
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        mesh.position.set(
          r * Math.sin(phi) * Math.cos(theta),
          r * Math.sin(phi) * Math.sin(theta),
          r * Math.cos(phi)
        );

        mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);

        const data = {
          mesh: mesh,
          type: type,
          velocity: new THREE.Vector3(
            (Math.random() - 0.5) * 0.02,
            (Math.random() - 0.5) * 0.02,
            (Math.random() - 0.5) * 0.02
          ),
          rotationSpeed: new THREE.Vector3(
            Math.random() * 0.02,
            Math.random() * 0.02,
            0
          ),
          treePos: this.calculateTreePosition(this.particles.length),
          scatterPos: mesh.position.clone()
        };

        this.mainGroup.add(mesh);
        this.particles.push(data);

        if (type === 'PHOTO') this.photos.push(data);
      }

      calculateTreePosition(index) {
        // Approximate spiral cone
        // Normalized index 0 (bottom) to 1 (top)
        const t = index / (CONFIG.counts.main + CONFIG.counts.dust);
        const maxRadius = 12;
        const height = 30;

        const y = (t * height) - (height / 2);
        const radius = maxRadius * (1 - t);
        const angle = t * 50 * Math.PI;

        return new THREE.Vector3(
          Math.cos(angle) * radius,
          y,
          Math.sin(angle) * radius
        );
      }

      // --- Logic & Events ---

      addPhotoToScene(texture) {
        const meshGroup = this.createPhotoMesh(texture);
        this.addParticleToSystem(meshGroup, 'PHOTO');
      }

      handleUpload(e) {
        const f = e.target.files[0];
        if (!f) return;

        const reader = new FileReader();
        reader.onload = (ev) => {
          new THREE.TextureLoader().load(ev.target.result, (t) => {
            t.colorSpace = THREE.SRGBColorSpace;
            this.addPhotoToScene(t);
          });
        }
        reader.readAsDataURL(f);
      }

      setupEventListeners() {
        window.addEventListener('resize', () => {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.composer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('imageInput').addEventListener('change', (e) => this.handleUpload(e));

        window.addEventListener('keydown', (e) => {
          if (e.key.toLowerCase() === 'h') {
            document.getElementById('ui-container').classList.toggle('ui-hidden');
          }
        });
      }

      // --- MediaPipe & CV ---

      async setupMediaPipe() {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );
        this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numHands: 1
        });
      }

      startWebcam() {
        const video = document.getElementById('webcam');
        const constraints = { video: true };
        navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
          video.srcObject = stream;
          video.addEventListener('loadeddata', () => {
            this.webcamRunning = true;
          });
        });
      }

      detectGestures() {
        if (!this.handLandmarker || !this.webcamRunning) return;

        const video = document.getElementById('webcam');
        if (video.currentTime === this.lastVideoTime) return;
        this.lastVideoTime = video.currentTime;

        const results = this.handLandmarker.detectForVideo(video, performance.now());

        if (results.landmarks.length > 0) {
          const lm = results.landmarks[0]; // First hand

          // Helper: Distance between two points
          const dist = (i1, i2) => Math.hypot(lm[i1].x - lm[i2].x, lm[i1].y - lm[i2].y);

          // 1. Pinch (Thumb tip 4, Index tip 8)
          const pinchDist = dist(4, 8);

          // 2. Average distance from tips to wrist (0)
          const tips = [8, 12, 16, 20];
          let avgDist = 0;
          tips.forEach(t => avgDist += dist(0, t));
          avgDist /= 4;

          // State Machine Triggers
          if (pinchDist < 0.05) {
            STATE.mode = 'FOCUS';
            if (STATE.targetPhotoIndex === -1 && this.photos.length > 0) {
              // Pick random photo
              STATE.targetPhotoIndex = Math.floor(Math.random() * this.photos.length);
            }
          } else if (avgDist < 0.25) {
            STATE.mode = 'TREE';
            STATE.targetPhotoIndex = -1;
          } else if (avgDist > 0.4) {
            STATE.mode = 'SCATTER';
            STATE.targetPhotoIndex = -1;
          }

          // Interaction Mapping (Palm Center #9)
          // Map x [0,1] -> rot Y [-1, 1]
          // Map y [0,1] -> rot X [-0.5, 0.5]
          const targetRotY = (lm[9].x - 0.5) * 3;
          const targetRotX = (lm[9].y - 0.5) * 1.5;

          // Smooth Hand Rotation
          STATE.handRotation.x = THREE.MathUtils.lerp(STATE.handRotation.x, targetRotX, 0.1);
          STATE.handRotation.y = THREE.MathUtils.lerp(STATE.handRotation.y, targetRotY, 0.1);
        }
      }

      // --- Animation Loop ---

      updateLayout(dt) {
        const lerpFactor = dt * 2.0;

        // Apply Hand Interaction Rotation to Main Group
        this.mainGroup.rotation.y = THREE.MathUtils.lerp(this.mainGroup.rotation.y, STATE.handRotation.y, 0.1);
        this.mainGroup.rotation.x = THREE.MathUtils.lerp(this.mainGroup.rotation.x, STATE.handRotation.x, 0.1);

        this.particles.forEach((p, idx) => {
          let targetPos, targetScale = 1;

          if (STATE.mode === 'TREE') {
            targetPos = p.treePos;
            // Reset rotation for photos in tree mode
            if (p.type === 'PHOTO') p.mesh.lookAt(0, p.mesh.position.y, 100);
          }
          else if (STATE.mode === 'SCATTER') {
            // Move slightly based on velocity
            p.scatterPos.add(p.velocity);
            // Boundary check simple bounce
            if (p.scatterPos.length() > 20) p.velocity.multiplyScalar(-1);
            targetPos = p.scatterPos;

            // Rotate particles in scatter mode
            p.mesh.rotation.x += p.rotationSpeed.x;
            p.mesh.rotation.y += p.rotationSpeed.y;
          }
          else if (STATE.mode === 'FOCUS') {
            if (p.type === 'PHOTO' && this.photos.indexOf(p) === STATE.targetPhotoIndex) {
              targetPos = CONFIG.focusPos;
              targetScale = 4.5;
              p.mesh.lookAt(this.camera.position);
            } else {
              // Others scatter back
              targetPos = p.scatterPos;
            }
          }

          // Apply Transform
          p.mesh.position.lerp(targetPos, lerpFactor);

          // Handle Scale logic
          const currentScale = p.mesh.scale.x;
          const nextScale = THREE.MathUtils.lerp(currentScale, targetScale, lerpFactor);
          p.mesh.scale.setScalar(nextScale);
        });
      }

      animate() {
        requestAnimationFrame(() => this.animate());

        const dt = this.clock.getDelta();

        this.detectGestures();
        this.updateLayout(dt);
        this.controls.update();

        this.composer.render();
      }
    }

    // Boot
    window.addEventListener('DOMContentLoaded', () => {
      new ChristmasExperience();
    });
  </script>
</body>

</html>
